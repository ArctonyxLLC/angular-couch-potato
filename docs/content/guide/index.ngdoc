@ngdoc overview
@name Couch Potato Overview and Guide
@description

## Couch Potato Overview and Usage Guide

Couch Potato aids in the lazy download and and run-time registration of:

 * controllers
 * factories
 * directives
 * values
 * filters
 * decorators

It supports hierarchies of dependencies within these components, expressed as
<a href="http://requirejs.org/" target="_blank">RequireJS</a> modules.  Applications can use Couch Potato to download and register components when they are needed to satisfy the requirements of a given *route*, or can do so ad-hoc in response to other application events.

*For the impatient, the hasty and the quick, you can stop reading and take a look at the
<a href="samples/" target="_blank">samples</a> or check out their <a href="https://github.com/stu-salsbury/angular-couch-potato/samples" target="_blank">source code</a>.*

*For the reference learner, you can dive straight into the <a href="#/api">API</a>.*

### This guide contains several sections:

The {@link 05-conceptual Conceptual Overview} section explains the purpose(s) for which
Couch Potato is intended and how its usage differs from traditional AngularJS
component definition and registration.

{@link 11-architecture Architecture using Couch Potato} describes how applications and their components are organized and authored in a Couch Potato context.

{@link 21-lazy-loading-via-routing Lazy Loading Via Routing} introduces the most common use case for Couch Potato -- loading and registering components in the context of route/state changes in the application.

{@link 31-lazy-loading-ad-hoc Ad Hoc Lazy Loading} demonstrates how arbitrary application code can invoke the download and registration of Couch Potato components.

{@link 41-thoughts Thoughts on Lazy Loading} is a sort of postlude in which some challenges and ideas for the future are presented, hopefully in a manner that is somewhat more organized than a ramble.

#### Of course, there is a {@link 03-faq FAQ} page.


## blah blah

describes how applications and their components are organized and authored in a Couch Potato context.


The various "use case" sections show how Couch Potato can be used in several
contexts:

* {@link 20a-with-ngRoute Use with ngRoute} demonstrates how Couch Potato can
be configured to load components when a particular **route** is activated during
a user's interaction with an application;
* {@link 20b-with-resolve Use with resolve} demonstrates how
Couch Potato can be configured to load *individual* components when a particular
**ui-router state** is acvtivated;
* {@link 20c-with-ui-templateProvider Use with templateProvider} demonstrates how Couch Potato can be configured to load a *set of components
along with a template* when a particular **ui-router view** is activated;
* {@link 20d-ad-hoc Use Ad Hoc} demonstrates how Couch Potato can be called
within application code that is outside the scope of any router.

Finally, some {@link 90-closing-thoughts closing thoughts} are presented with the
hope of stimulating discussion and interest in participating in Couch Potato
specifically and the development of tools and techniques for building big
applications/sites with AngularJS in general.

